#!/usr/bin/env bash
set -euo pipefail

# MannyKnows Unified Deployment Script
# Enforces "no raw git" policy and exposes the flows people reach for most,
# so they never need to type git directly.

# ========================
# Config (tweak as needed)
# ========================
: "${BASE_BRANCH:=development}"                    # Where features branch from / sync with
: "${PROTECTED_BRANCHES:=production main master}"  # Cannot force-push or create from scratch
: "${BUILD_TIMEOUT:=900}"                          # seconds (15 min)
: "${PUSH_TIMEOUT:=180}"                           # seconds (3 min)
: "${ALLOW_FORCE_WITH_LEASE_FOR_FEATURE:=1}"       # 1=yes, 0=no
: "${COMMIT_TOKEN:=[via-deploy.sh]}"               # token required in commit messages
: "${DEFAULT_COMMIT_PREFIX:=Update}"               # default message prefix
: "${DRY_RUN:=0}"                                  # 1=show steps only
: "${NO_BUILD:=0}"                                 # 1=skip build
: "${PR_AUTO_CREATE:=1}"                           # 1=try to create PR via gh for feature/*
: "${ENFORCE_HOOK:=1}"                             # 1=ensure commit-msg hook installed
: "${RELEASE_NOTES:=}"                             # optional multi-line notes when --release

# ============
# UI helpers
# ============
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; PURPLE='\033[0;35m'; NC='\033[0m'
say() { echo -e "${2:-$BLUE}$1${NC}"; }
die() { say "‚ùå $1" "$RED"; exit 1; }
ok()  { say "‚úÖ $1" "$GREEN"; }
warn(){ say "‚ö†Ô∏è  $1" "$YELLOW"; }
info(){ say "‚ÑπÔ∏è  $1" "$BLUE"; }

confirm() {
  local msg="$1"
  warn "$msg"
  read -p "Continue? (y/N): " -n 1 -r; echo
  [[ $REPLY =~ ^[Yy]$ ]] || { say "Cancelled." "$BLUE"; exit 0; }
}

# ============
# Preconditions
# ============
need() { command -v "$1" >/dev/null 2>&1 || die "Missing required tool: $1"; }
ensure_repo() { git rev-parse --git-dir >/dev/null 2>&1 || die "Not in a git repo."; }
root_guard() {
  [[ -f package.json ]] || die "package.json not found. Run from repo root."
}

git_net_ok() {
  git ls-remote --exit-code origin >/dev/null 2>&1 || die "Cannot reach origin. Check network/auth."
}

# ==================
# Commit hook policy
# ==================
ensure_commit_hook() {
  [[ "$ENFORCE_HOOK" -eq 1 ]] || return 0

  local hook=".git/hooks/commit-msg"
  if [[ -f "$hook" ]]; then
    grep -q "$COMMIT_TOKEN" "$hook" && return 0
  fi

  info "Installing commit-msg policy hook to enforce $COMMIT_TOKEN‚Ä¶"
  cat > "$hook" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
TOKEN="${COMMIT_TOKEN:-[via-deploy.sh]}"
MSG_FILE="$1"
if ! grep -q "$TOKEN" "$MSG_FILE"; then
  echo "Commit rejected: missing token $TOKEN. Use deploy.sh to commit." >&2
  exit 1
fi
EOF
  # inject current token
  sed -i.bak "s|\${COMMIT_TOKEN:-\[via-deploy.sh\]}|${COMMIT_TOKEN}|g" "$hook" && rm -f "$hook.bak"
  chmod +x "$hook"
  ok "Commit policy hook installed."
}

# ==================
# Git helpers
# ==================
curr_branch() { git rev-parse --abbrev-ref HEAD; }
branch_exists_local() { git show-ref --verify --quiet "refs/heads/$1"; }
branch_exists_remote() { git ls-remote --exit-code --heads origin "$1" >/dev/null 2>&1; }
is_protected() {
  local b="$1"
  for p in $PROTECTED_BRANCHES; do [[ "$b" == "$p" ]] && return 0; done
  return 1
}
is_feature() { [[ "$1" =~ ^feature/ ]]; }

require_clean_or_stash() {
  if ! git diff --quiet || ! git diff --staged --quiet; then
    warn "You have uncommitted changes."
    echo "Options:"
    echo "1) Commit via this script now"
    echo "2) Stash changes (git stash)"
    echo "3) Abort"
    read -p "Choose (1/2/3): " -n 1 -r; echo
    case "$REPLY" in
      1) return 0;;
      2) git stash && ok "Changes stashed.";;
      *) say "Cancelled." "$BLUE"; exit 0;;
    esac
  fi
}

safe_checkout() {
  local b="$1"
  if branch_exists_local "$b"; then
    git checkout "$b"
  elif branch_exists_remote "$b"; then
    git checkout -b "$b" "origin/$b"
  else
    git checkout -b "$b"
  fi
}

ff_sync() {
  local base="${1:-$BASE_BRANCH}"
  info "Syncing with $base (fast-forward)‚Ä¶"
  git fetch origin "$base"
  git checkout "$base" || true
  git pull --ff-only origin "$base"
}

rebase_onto() {
  local base="${1:-$BASE_BRANCH}"
  local b; b=$(curr_branch)
  [[ "$b" == "$base" ]] && return 0
  info "Rebasing $b onto $base‚Ä¶"
  git fetch origin "$base"
  git rebase "origin/$base"
}

push_branch() {
  local branch="$1" force="$2"
  info "Pushing to origin/$branch‚Ä¶"

  # No force to production/main/master
  if is_protected "$branch"; then
    [[ "$force" -eq 1 ]] && die "Force push to protected branch '$branch' is blocked."
    git push origin "HEAD:$branch"
    return
  fi

  # feature branches may use --force-with-lease when allowed
  if is_feature "$branch" && [[ "$ALLOW_FORCE_WITH_LEASE_FOR_FEATURE" -eq 1 ]] && [[ "$force" -eq 1 ]]; then
    git push --force-with-lease origin "HEAD:$branch"
  else
    git push origin "HEAD:$branch"
  fi
}

timeboxed() { # timeboxed <seconds> <cmd...>
  local t="$1"; shift
  local logfile="/tmp/deploy-$(date +%s)-$$.log"
  ( "$@" >"$logfile" 2>&1 ) &
  local pid=$!
  local start=$(date +%s)
  echo -n "   "
  while kill -0 "$pid" 2>/dev/null; do
    echo -n "."
    sleep 1
    (( $(date +%s) - start > t )) && { kill "$pid" 2>/dev/null || true; echo; die "Timeout running: $* (see $logfile)"; }
  done
  wait "$pid" || { echo; tail -20 "$logfile" | sed 's/^/   /'; die "Command failed: $*"; }
  echo
}

# ==================
# Build helpers
# ==================
ensure_deps() {
  if [[ ! -d node_modules ]]; then
    warn "node_modules missing. Installing dependencies‚Ä¶"
    timeboxed 600 npm install
  fi
}

run_build() {
  [[ "$NO_BUILD" -eq 1 ]] && { warn "Skipping build (NO_BUILD=1)"; return; }
  jq -r '.scripts.build' package.json >/dev/null 2>&1 || die "No build script in package.json."
  say "üì¶ Building project‚Ä¶" "$YELLOW"
  timeboxed "$BUILD_TIMEOUT" npm run build
  ok "Build successful."
  # cleanup macOS artifacts
  find dist/ -name "._*" -delete 2>/dev/null || true
  find dist/ -name ".DS_Store" -delete 2>/dev/null || true
  if [[ -d dist ]]; then
    local sz alloc
    sz=$(ls -la dist/ dist/_astro/ 2>/dev/null | awk '!/^d/ {s+=$5} END{printf "%.1fKB", s/1024}')
    alloc=$(du -sh dist 2>/dev/null | cut -f1)
    info "Build size: ${sz:-unknown} (${alloc:-unknown} allocated)"
  fi
}

# ==================
# Commit helpers
# ==================
do_commit_all() {
  local msg="$1"
  git add -A
  if git diff --cached --quiet; then
    warn "No staged changes; skipping commit."
    return 1
  fi
  # enforce token
  [[ "$msg" == *"$COMMIT_TOKEN"* ]] || msg="$msg $COMMIT_TOKEN"
  say "üìù Committing‚Ä¶" "$YELLOW"
  git commit -m "$msg" || die "Commit failed."
  ok "Committed."
  return 0
}

# ==================
# PR helpers
# ==================
maybe_create_pr() {
  local branch="$1"
  [[ "$PR_AUTO_CREATE" -eq 1 ]] || return 0
  command -v gh >/dev/null 2>&1 || { warn "gh not installed; skipping PR creation."; return 0; }
  is_feature "$branch" || return 0

  if gh pr view "$branch" --json number >/dev/null 2>&1; then
    info "PR already exists: $(gh pr view "$branch" --json url --jq .url)"
    return 0
  fi

  say "Creating PR ($branch ‚Üí $BASE_BRANCH) ‚Ä¶" "$GREEN"
  local prurl
  if prurl=$(gh pr create \
      --title "$branch: $(git log -1 --pretty=%s)" \
      --body "Auto PR by deploy script.\n\nBranch: \`$branch\`\nBase: \`$BASE_BRANCH\`" \
      --base "$BASE_BRANCH" \
      --head "$branch" 2>/dev/null); then
    ok "PR: $prurl"
  else
    warn "Could not auto-create PR. Open manually in GitHub."
  fi
}

# ==================
# Release helpers
# ==================
do_release() { # do_release vX.Y.Z
  local tag="$1"
  [[ "$tag" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]] || die "Tag must be semver like v1.2.3"
  confirm "Tag '$tag' and push to origin?"
  git tag -a "$tag" -m "Release $tag ${COMMIT_TOKEN}"
  git push origin "$tag"
  ok "Tag pushed: $tag"

  if command -v gh >/dev/null 2>&1; then
    local notes="${RELEASE_NOTES:-Release $tag}"
    gh release create "$tag" --notes "$notes" || warn "GitHub release creation failed."
  fi
}

# ==================
# Commands
# ==================
usage() {
cat <<EOF
Usage:
  ./deploy.sh                                # Commit & push current branch (build+default msg)
  ./deploy.sh "message"                       # Commit & push current branch with message
  ./deploy.sh feature/xyz ["message"]         # Create/switch feature, build, commit, push
  ./deploy.sh development|production ["msg"]  # Deploy to env branches

Branch mgmt:
  ./deploy.sh --cleanup feature/xyz           # Delete feature (local+remote) and close PR
  ./deploy.sh --status                        # Show status
  ./deploy.sh --rollback                      # Undo last commit (keep changes)
  ./deploy.sh --list-branches                 # List branches
  ./deploy.sh --switch branch                 # Safe switch (with stash option)
  ./deploy.sh --sync [base]                   # FF + rebase current branch onto base (default: $BASE_BRANCH)

Quality-of-life:
  ./deploy.sh --dry-run ...                   # Preview actions only
  NO_BUILD=1 ./deploy.sh ...                  # Skip build
  ./deploy.sh --release vX.Y.Z                # Tag + push (and GH release if gh is installed)

Policy:
  Enforces commit token: $COMMIT_TOKEN (via commit-msg hook)
EOF
}

# ==================
# Entry
# ==================
ensure_repo
root_guard
need git
need npm
git_net_ok
ensure_commit_hook

# Parse flags
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then usage; exit 0; fi
if [[ "${1:-}" == "--dry-run" ]]; then DRY_RUN=1; shift; fi
cmd="${1:-}"

# Special commands
case "$cmd" in
  --status)
    say "üìä Git Status"; say "Branch: $(curr_branch)" "$GREEN"
    git status -s
    say "üìö Recent Commits:"; git --no-pager log --oneline -5 | sed 's/^/  /'
    exit 0
    ;;
  --list-branches)
    say "üåø Local branches:" "$GREEN"; git branch | sed 's/^/  /'
    echo; say "üåø Remote branches:" "$GREEN"; git branch -r | sed 's/^/  /'
    exit 0
    ;;
  --rollback)
    say "üîÑ Rollback last commit (keeping changes)"; confirm "Reset HEAD~1?"
    git reset HEAD~1
    ok "Rolled back."
    exit 0
    ;;
  --switch)
    shift || die "Provide a branch name."
    require_clean_or_stash
    safe_checkout "$1"; ok "Switched to $1"; exit 0
    ;;
  --cleanup)
    shift || die "Provide a feature branch name."
    local b="$1"
    [[ "$b" =~ ^feature/ ]] || die "Can only cleanup feature/* branches."
    confirm "Delete branch '$b' locally and remotely and close PR?"
    local curr; curr=$(curr_branch)
    [[ "$curr" == "$b" ]] && git checkout "$BASE_BRANCH" || true
    branch_exists_local "$b" && git branch -D "$b" || true
    branch_exists_remote "$b" && git push origin --delete "$b" || true
    if command -v gh >/dev/null 2>&1; then gh pr close "$b" --comment "Closed via deploy script" || true; fi
    ok "Cleanup complete."
    exit 0
    ;;
  --sync)
    shift || true
    base="${1:-$BASE_BRANCH}"
    require_clean_or_stash
    ff_sync "$base"
    git checkout - >/dev/null 2>&1 || true
    rebase_onto "$base"
    ok "Synced with $base."
    exit 0
    ;;
  --release)
    shift || die "Provide a tag like v1.2.3"
    do_release "$1"; exit 0
    ;;
esac

# Determine mode (branch or message)
CURRENT=$(curr_branch)
ENVIRONMENT="$CURRENT"
COMMIT_MSG="${2:-"$DEFAULT_COMMIT_PREFIX $CURRENT: $(date '+%Y-%m-%d %H:%M:%S')"}"

if [[ -n "${cmd}" && "${cmd}" != "$CURRENT" && "${cmd}" != "$COMMIT_MSG" ]]; then
  # First arg provided
  if [[ "$cmd" =~ ^(development|production|feature/.*|hotfix/.*)$ ]]; then
    ENVIRONMENT="$cmd"
    # If two args, second is message
    [[ $# -ge 2 ]] && COMMIT_MSG="$2"
    if [[ "$CURRENT" != "$ENVIRONMENT" ]]; then
      require_clean_or_stash
      if ! branch_exists_local "$ENVIRONMENT" && ! branch_exists_remote "$ENVIRONMENT"; then
        is_protected "$ENVIRONMENT" && die "Cannot create protected branch '$ENVIRONMENT'."
        if [[ "$ENVIRONMENT" =~ ^feature/ ]]; then
          ff_sync "$BASE_BRANCH"
          git checkout "$BASE_BRANCH"
          git pull --ff-only origin "$BASE_BRANCH"
        fi
        safe_checkout "$ENVIRONMENT"
        ok "Created/switch to $ENVIRONMENT"
      else
        safe_checkout "$ENVIRONMENT"
        ok "Switched to $ENVIRONMENT"
      fi
    fi
  else
    # Arg is a custom commit message on current branch
    COMMIT_MSG="$cmd"
  fi
fi

# Production guard
if [[ "$ENVIRONMENT" == "production" ]]; then
  confirm "You are about to deploy to PRODUCTION."
fi

# Dry-run banner
[[ "$DRY_RUN" -eq 1 ]] && warn "DRY-RUN mode: no write actions will be executed."

# Build + commit + push
ensure_deps
[[ "$DRY_RUN" -eq 1 ]] || run_build

# If no changes, allow pushing anyway (e.g., empty build)
if ! git diff --quiet || ! git diff --staged --quiet; then
  [[ "$DRY_RUN" -eq 1 ]] || do_commit_all "$COMMIT_MSG" || warn "Nothing to commit."
else
  warn "No local changes detected before push."
fi

git_net_ok

# Choose push strategy
force_flag=0
if is_feature "$ENVIRONMENT"; then
  force_flag=1   # allow with lease, avoids "stuck" feature branches
fi
[[ "$DRY_RUN" -eq 1 ]] || timeboxed "$PUSH_TIMEOUT" push_branch "$ENVIRONMENT" "$force_flag"

ok "Deployed to $ENVIRONMENT."
say "üîó Repo: https://github.com/showyouhow83/MannyKnows/tree/${ENVIRONMENT}"

# PR for features
[[ "$DRY_RUN" -eq 1 ]] || maybe_create_pr "$ENVIRONMENT"

# Summary
say "üèÅ Summary" "$GREEN"
say "Branch: $ENVIRONMENT"
say "Time: $(date '+%Y-%m-%d %H:%M:%S')"
